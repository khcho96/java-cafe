# 미션 - 카페 주문 대기열 시뮬레이터

## 🔍 진행 방식

- 미션은 **기능 요구 사항, 프로그래밍 요구 사항, 과제 진행 요구 사항** 세 가지로 구성되어 있다.
- 세 개의 요구 사항을 만족하기 위해 노력한다.  
  특히 기능을 구현하기 전에 기능 목록을 만들고, 기능 단위로 커밋하는 방식으로 진행한다.
- 기능 요구 사항에 기재되지 않은 내용은 스스로 판단하여 구현한다.

---

## 📮 미션 제출 방법

- 미션 구현을 완료한 후 GitHub을 통해 제출해야 한다.
   - GitHub을 활용한 제출 방법은 `프리코스 과제 제출` 문서를 참고해 제출한다.
- GitHub에 미션을 제출한 후 `지원 플랫폼` 사이트에 접속하여 프리코스 과제를 제출한다.
   - 자세한 방법은 `제출 가이드`를 참고한다.
   - **지원 플랫폼을 통해 과제를 제출하지 않으면 최종 제출되지 않은 것으로 처리**한다.

---

## 🚨 과제 제출 전 체크 리스트 - 0점 방지

- 기능 구현을 모두 정상적으로 했더라도  
  **요구 사항에 명시된 출력 형식(문구, 에러 메시지 형식 등)을 지키지 않을 경우 0점으로 처리**한다.
- 기능 구현을 완료한 뒤 아래 가이드에 따라 테스트를 실행했을 때 모든 테스트가 성공하는지 확인한다.
- **테스트가 실패할 경우 0점으로 처리**한다.

### 테스트 실행 가이드

- 터미널에서 `java -version`을 실행하여 Java 버전이 17인지 확인한다.  
  Eclipse 또는 IntelliJ IDEA와 같은 IDE에서 Java 17로 실행되는지 확인한다.
- 터미널에서 Mac 또는 Linux 사용자의 경우 `./gradlew clean test` 명령을 실행하고,  
  Windows 사용자의 경우 `gradlew.bat clean test` 또는 `./gradlew.bat clean test` 명령을 실행할 때  
  모든 테스트가 아래와 같이 통과하는지 확인한다.

~~~text
BUILD SUCCESSFUL in 0s
~~~

---

## 🚀 기능 요구 사항

> 이번 미션은 이메일 형식의 기능 요구 사항입니다.  
> 문제를 구현하는 데 필요한 요구사항과 배경지식은 이메일 내용에 전부 담겨있으니,  
> 꼼꼼하게 확인하고 필요하다면 주어진 문제의 내용을 통해 유추하고 스스로 판단해 구현해 주세요.  
> 문제의 모든 내용은 충분히 검토되었으며, 출제 의도를 담은 내용임을 알려드립니다.

보낸 사람: 카페 운영팀 `<ops@cafe.io>`  
받는 사람: 개발팀 `<dev@cafe.io>`

제목: 카페 주문 대기열 시뮬레이터 개발 요청

안녕하세요. 카페 운영팀입니다!

저희 동네 작은 카페가 점점 인기를 얻으면서, 출근 시간대와 주말 오후에  
손님들이 한꺼번에 몰리는 상황이 자주 발생하고 있습니다.

현재 카페에는 **2명의 바리스타(직원)**가 있으며,  
손님들은 줄을 서서 음료와 디저트를 주문합니다.

운영팀에서는 아래와 같은 고민을 가지고 있습니다.

1. 손님들이 실제로 **얼마나 기다리는지** 알고 싶어요.
2. 두 직원에게 일이 **공평하게 나눠지는지** 확인하고 싶어요.
3. 특정 시간대에 발생한 **총 매출, 음료 매출, 디저트 매출**을 한 번에 보고 싶어요.

이 목표를 위해, **줄에 서 있는 손님들의 주문 정보를 입력으로 받아서**

- 각 손님의 **대기 시간**
- 각 손님의 **주문 제조 시간 및 완료 시각**
- **직원별 작업 시간**
- **대기 시간 통계**
- **매출 통계**

를 계산해 주는 **“카페 주문 대기열 시뮬레이터”**를 만들어 주셨으면 합니다.

아래 메뉴와 규칙, 예시를 참고해 주세요.

---

### 메뉴

~~~text
<커피>
아메리카노(4,000)  - 제조 시간 2분
카페라떼(4,500)   - 제조 시간 3분
바닐라라떼(5,000) - 제조 시간 3분
콜드브루(4,500)   - 제조 시간 2분

<논커피 음료>
초코라떼(5,000)   - 제조 시간 3분
녹차라떼(5,000)   - 제조 시간 3분
허브티(4,000)     - 제조 시간 2분

<디저트>
치즈케이크(5,500) - 제조 시간 0분 (진열된 제품 제공)
마카롱세트(7,000) - 제조 시간 0분
브라우니(4,500)   - 제조 시간 0분
~~~

- **가격**은 매출 계산에 사용됩니다.
- **제조 시간**은 대기 시간 및 직원별 작업 시간 계산에 사용됩니다.
- 디저트는 이미 진열된 제품을 바로 제공하므로 **제조 시간은 0분**입니다.  
  (단, 주문 개수 제한과 매출 계산에는 포함됩니다.)

---

### 시뮬레이션 규칙

#### 직원(바리스타) 설정

- 카페에는 항상 **2명의 직원**이 있습니다.
   - 직원 A
   - 직원 B
- 두 직원은 동일한 속도로 일하며, 동시에 서로 다른 손님의 주문을 처리할 수 있습니다.
- **한 손님의 주문은 한 명의 직원이 전담**합니다.
   - 한 손님의 주문에 여러 메뉴가 있어도, 그 주문 전체는 한 직원이 처리합니다.
   - 한 주문을 두 직원이 나누어 만드는 일은 없습니다.

#### 주문의 제조 시간

- 한 손님의 **주문 제조 시간**은  
  각 메뉴의 `제조 시간 × 수량`의 합입니다.
- 디저트는 제조 시간이 0분이므로, 제조 시간 합에 영향을 주지 않습니다.

#### 주문 배정 규칙

손님들은 입력 순서대로 1번, 2번, 3번… 순서의 번호를 부여받습니다.

각 손님에 대해, 프로그램은 다음 규칙으로 직원에게 주문을 배정합니다.

1. 직원 A와 직원 B 각각의 **현재 작업 종료 예정 시각**을 `endA`, `endB`라고 합니다.
   - 시뮬레이션 시작 시점에는 `endA = 0`, `endB = 0`에서 시작합니다.
2. 새로운 손님의 주문을 배정할 때,
   - `endA <= endB`라면 해당 주문은 **직원 A**에게 배정합니다.
   - 그렇지 않다면 **직원 B**에게 배정합니다.
3. 손님의 **대기 시간**은, 그 손님이 배정된 직원의 **현재 종료 예정 시각**입니다.
4. 손님의 **완료 시각**은  
   `대기 시간 + 주문 제조 시간`입니다.
5. 주문 완료 후, 해당 직원의 종료 예정 시각을 **해당 손님의 완료 시각으로 갱신**합니다.

> 예시
> - 직원 A: `endA = 4분`, 직원 B: `endB = 6분`인 상황에서
> - 새로운 손님의 주문 제조 시간이 `3분`이라면
    >   - `endA <= endB`이므로 직원 A에게 배정
>   - 대기 시간 = 4분
>   - 완료 시각 = 4 + 3 = 7분
>   - 갱신 후 `endA = 7분`

---

### 시뮬레이션 입력 규칙

프로그램은 다음 순서로 입력을 받습니다.

---

#### 1. 현재 줄에 서 있는 손님 수 입력

- 출력 메시지

~~~text
현재 줄에 서 있는 손님 수를 입력해 주세요.
~~~

- 손님 수는 **1 이상 20 이하의 정수**만 입력받는다.
- 아래 경우는 모두 잘못된 입력이다.
   - 1 미만 또는 20 초과
   - 정수가 아님 (예: `abc`, `1.5` 등)
- 잘못된 입력일 경우:

~~~text
[ERROR] 유효하지 않은 손님 수입니다. 다시 입력해 주세요.
~~~

를 출력하고, **손님 수 입력부터 다시** 받는다.

- 모든 에러 메시지는 `"[ERROR]"`로 시작해야 한다.

---

#### 2. 각 손님의 주문 입력

손님 수가 `N`명이라면, 1번 손님부터 N번 손님까지 순서대로 주문을 입력받는다.

- 각 손님에 대해 출력 메시지 예시는 다음과 같다.

~~~text
1번 손님의 주문을 입력해 주세요. (e.g. 아메리카노-2,치즈케이크-1)
~~~

- 입력 형식
   - `메뉴이름-수량`을 `,`로 구분한 문자열
   - 예:
      - `아메리카노-2,치즈케이크-1`
      - `카페라떼-1, 브라우니-2` (콤마 뒤 공백은 허용 가능)

- 주문 입력에 대한 제약 조건
   1. 메뉴판에 존재하는 메뉴 이름만 사용할 것
   2. 수량은 **1 이상의 정수**만 허용
   3. 하나의 주문 내에서 **같은 메뉴를 중복해서 입력할 수 없음**
      - 예: `아메리카노-1,아메리카노-2` → 잘못된 입력
   4. 한 손님이 주문하는 **전체 메뉴 개수의 합은 최소 1개, 최대 10개**
      - 예: `아메리카노-5,카페라떼-3,치즈케이크-3` → 총 11개 → 잘못된 입력
   5. 형식은 `메뉴이름-수량`이어야 하며, 다른 구분자(예: `=`, `:` 등)를 사용하면 잘못된 입력으로 처리

- 위 조건 중 하나라도 위반할 경우, 아래와 같은 에러 메시지를 출력한다.

~~~text
[ERROR] 유효하지 않은 주문입니다. 다시 입력해 주세요.
~~~

그리고 **해당 손님의 주문 입력부터 다시** 받는다.

- 모든 에러 메시지는 `"[ERROR]"`로 시작해야 한다.

---

### 시뮬레이션 결과에서 보여줄 내용

모든 손님의 입력이 정상적으로 끝나면, 프로그램은 다음 항목을 순서대로 출력한다.

1. 손님별 주문 및 대기/완료 정보
2. 직원별 작업 시간
3. 대기 시간 통계
4. 매출 통계

---

#### 1. 손님별 주문 및 대기 정보

- 섹션 제목 예시:

~~~text
<손님별 주문 및 대기 시간>
~~~

- 각 손님에 대해 다음 정보를 출력한다.

~~~text
1번 손님: 아메리카노 2개, 치즈케이크 1개
 - 대기 시간: 0분
 - 주문 제조 시간: 4분
 - 주문 완료 시각: 4분
~~~

- 손님 번호는 입력 순서대로 `1번, 2번, ...`이다.
- 주문 메뉴의 출력 순서는 자유롭게 정해도 된다.

---

#### 2. 직원별 작업 시간

~~~text
<직원별 작업 시간>
직원 A 총 작업 시간: 8분
직원 B 총 작업 시간: 5분
가장 많이 일한 직원: 직원 A
~~~

- 직원 A, 직원 B의 **총 작업 시간**을 출력한다.
   - 총 작업 시간 = 해당 직원의 최종 종료 예정 시각(`endA`, `endB`).
- “가장 많이 일한 직원”은 작업 시간이 더 긴 직원을 출력한다.
   - 두 직원의 작업 시간이 동일한 경우  
     `"동일(두 직원 모두 같은 시간)"` 등의 문구를 사용해도 된다.

---

#### 3. 대기 시간 통계

~~~text
<대기 시간 통계>
가장 오래 기다린 손님 번호: 3번
가장 오래 기다린 손님의 대기 시간: 12분
평균 대기 시간: 4.8분
~~~

- 대기 시간 통계 항목:
   1. **가장 오래 기다린 손님 번호**
      - 대기 시간이 가장 큰 손님 번호
      - 여러 명이 같은 최대 대기 시간을 가진다면, **번호가 가장 작은 손님**을 선택한다.
   2. **가장 오래 기다린 손님의 대기 시간(분)**
   3. **평균 대기 시간(분)**
      - 모든 손님의 대기 시간 평균을 **소수점 첫째 자리까지 반올림**하여 출력한다.  
        (예: `1.0분`, `2.8분`, `4.5분`)

---

#### 4. 매출 통계

~~~text
<매출 통계>
총 매출: 45,500원
음료 매출: 23,000원
디저트 매출: 22,500원
~~~

- **총 매출**: 모든 주문의 `(메뉴 가격 × 수량)`의 합
- **음료 매출**: 커피 + 논커피 음료 카테고리의 금액 합
- **디저트 매출**: 디저트 카테고리의 금액 합
- 금액 표기 형식(쉼표, “원” 여부 등)은 예시와 비슷하게 통일감 있게 구현한다.

---

### 기대하는 ‘카페 주문 대기열 시뮬레이터’의 예시 모습

> 수치는 예시이며, 실제 계산과 다를 수 있습니다.

~~~text
현재 줄에 서 있는 손님 수를 입력해 주세요.
3
1번 손님의 주문을 입력해 주세요. (e.g. 아메리카노-2,치즈케이크-1)
아메리카노-2,치즈케이크-1
2번 손님의 주문을 입력해 주세요. (e.g. 아메리카노-2,치즈케이크-1)
카페라떼-1,브라우니-2
3번 손님의 주문을 입력해 주세요. (e.g. 아메리카노-2,치즈케이크-1)
콜드브루-3

=== 카페 주문 대기열 결과 ===

<손님별 주문 및 대기 시간>
1번 손님: 아메리카노 2개, 치즈케이크 1개
 - 대기 시간: 0분
 - 주문 제조 시간: 4분
 - 주문 완료 시각: 4분

2번 손님: 카페라떼 1개, 브라우니 2개
 - 대기 시간: 0분
 - 주문 제조 시간: 3분
 - 주문 완료 시각: 3분

3번 손님: 콜드브루 3개
 - 대기 시간: 4분
 - 주문 제조 시간: 6분
 - 주문 완료 시각: 10분

<직원별 작업 시간>
직원 A 총 작업 시간: 10분
직원 B 총 작업 시간: 3분
가장 많이 일한 직원: 직원 A

<대기 시간 통계>
가장 오래 기다린 손님 번호: 3번
가장 오래 기다린 손님의 대기 시간: 4분
평균 대기 시간: 1.3분

<매출 통계>
총 매출: 52,000원
음료 매출: 37,000원
디저트 매출: 15,000원
~~~

---

## 🎯 프로그래밍 요구 사항

- JDK 17 버전에서 실행 가능해야 한다.  
  **JDK 17에서 정상적으로 동작하지 않을 경우 0점 처리**한다.
- 프로그램 실행의 시작점은 `Application`의 `main()`이다.
- `build.gradle` 파일을 변경할 수 없고, 외부 라이브러리를 사용하지 않는다.
- [Java 코드 컨벤션](https://github.com/woowacourse/woowacourse-docs/tree/master/styleguide/java) 가이드를 준수하며 프로그래밍한다.
- 프로그램 종료 시 `System.exit()`를 호출하지 않는다.
- 프로그램 구현이 완료되면 `ApplicationTest`의 모든 테스트가 성공해야 한다.  
  **테스트가 실패할 경우 0점 처리**한다.
- 프로그래밍 요구 사항에서 달리 명시하지 않는 한, 파일·패키지 이름을 수정하거나 이동하지 않는다.

### 코드 스타일 제약

- indent(인덴트, 들여쓰기) depth를 **3이 넘지 않도록** 구현한다.  
  **2까지 허용**한다.
   - 예: while문 안에 if문이 있으면 들여쓰기는 2이다.
   - 들여쓰기를 줄이기 위해 메서드를 분리하는 방식을 적극 활용한다.
- **3항 연산자를 쓰지 않는다.**
- 함수(또는 메서드)의 길이가 **15라인을 넘어가지 않도록** 구현한다.
   - 한 메서드는 한 가지 일만 하도록 최대한 작게 만든다.
- `else` 예약어를 쓰지 않는다.
   - 힌트: if 조건절에서 값을 `return` 하는 방식으로 구현하면 `else`를 사용하지 않아도 된다.
   - `switch/case`도 허용하지 않는다.

### 테스트 관련 요구 사항

- JUnit 5와 AssertJ를 이용하여 **도메인 로직(시뮬레이션/계산 로직)**에 대한 단위 테스트를 구현해야 한다.
   - 예:
      - 주문의 총 제조 시간 계산
      - 직원 배정 및 대기 시간 계산
      - 직원별 총 작업 시간 계산
      - 매출 통계 계산
- UI(System.out, System.in, Console 등) 로직은 단위 테스트 대상에서 제외한다.
- **핵심 로직을 구현하는 코드와 UI를 담당하는 로직을 분리**해 구현한다.

### 예외 처리 요구 사항

- 사용자가 잘못된 값을 입력할 경우 `IllegalArgumentException`을 발생시킨다.
- 예외 발생 시, `"[ERROR]"`로 시작하는 에러 메시지를 출력한 후,  
  **그 부분부터 입력을 다시 받는다.**
   - 손님 수가 잘못된 경우: 손님 수 입력부터 다시
   - 특정 손님의 주문이 잘못된 경우: 해당 손님의 주문 입력부터 다시
- `Exception`이 아닌 `IllegalArgumentException`, `IllegalStateException` 등  
  명확한 유형의 예외를 사용해 처리한다.

---

### 추가된 요구 사항 (입출력 클래스)

- 아래 있는 `InputView`, `OutputView` 클래스를 참고하여 입출력 클래스를 구현한다.
   - 입력과 출력을 담당하는 클래스를 별도로 구현한다.
   - 해당 클래스의 패키지, 클래스명, 메서드의 반환 타입과 시그니처는 자유롭게 구현할 수 있다.

~~~java
public class InputView {
    public int readCustomerCount() {
        System.out.println("현재 줄에 서 있는 손님 수를 입력해 주세요.");
        String input = Console.readLine();
        // ...
    }

    public String readOrderOf(int customerNumber) {
        System.out.println(customerNumber + "번 손님의 주문을 입력해 주세요. (e.g. 아메리카노-2,치즈케이크-1)");
        return Console.readLine();
    }
}
~~~

~~~java
public class OutputView {
    public void printResult(/* 결과 DTO 등 */) {
        System.out.println("=== 카페 주문 대기열 결과 ===");
        // ...
    }
}
~~~

### 라이브러리

- `camp.nextstep.edu.missionutils`에서 제공하는 `Console` API를 사용하여 구현해야 한다.
   - 사용자가 입력하는 값은 `camp.nextstep.edu.missionutils.Console`의 `readLine()`을 활용한다.

---

## ✏️ 과제 진행 요구 사항

- 미션은 예를 들어 `java-cafe-waiting-simulator` 저장소를 **비공개** 저장소로 생성해 시작한다.
- **기능을 구현하기 전 `docs/README.md`에 구현할 기능 목록을 정리**해 추가한다.
   - 예시:
      - 메뉴 정보를 초기화한다.
      - 손님 수를 입력받고 검증한다.
      - 손님별 주문을 입력받고 파싱/검증한다.
      - 직원별로 주문을 배정하고 대기 시간과 완료 시각을 계산한다.
      - 직원별 총 작업 시간, 대기 시간 통계, 매출 통계를 계산한다.
      - 결과를 형식에 맞게 출력한다.
- **Git의 커밋 단위는 앞 단계에서 `docs/README.md`에 정리한 기능 목록 단위**로 추가한다.
   - [커밋 메시지 컨벤션](https://gist.github.com/stephenparish/9941e89d80e2bc58a153) 가이드를 참고해 커밋 메시지를 작성한다.
- 과제 진행 및 제출 방법은 `프리코스 과제 제출` 문서를 참고한다.

## 기능 구현 목록
1. 손님 수를 입력받는다.
   - 예외 사항
      1. 빈문자열이면 예외 발생
      2. 숫자가 아니면 예외 발생
      3. **1 이상 20 이하**의 정수가 아니면 예외 발생
   - 예외 메시지
      - [ERROR] 유효하지 않은 손님 수입니다. 다시 입력해 주세요.
2. 각 손님의 주문을입력받는다.
   - 예외 사항
      1. 빈문자열이면 예외 발생
      2. 형식에 맞지 않으면 예외 발생
      3. 메뉴판에 없는 메뉴이면 예외 발생
      4. 수량이 1 이상의 정수가 아니면 예외 발생
      5. 메뉴 중복이면 예외 발생
      6. 주문 메뉴 개수의 합이 1 이상 10 이하가 아니면 예외 발생
   - 예외 메시지
      - [ERROR] 유효하지 않은 주문입니다. 다시 입력해 주세요.
3. 각 손님의 주문을 계산한다.
   1. 주문에 메뉴와 가격을 저장한다.
   2. 바리스타 A, B 중 작업이 더 빨리 끝나는 바리스타에게 주문(손님)을 할당한다.(동일하면 A에게)
      - 바리스타에게 주문을 할당할 때 바리타의 총 작업시간을 업데이트한다.
      - 할당되는 바리스타의 작업 내용을 변경한다.
      - 할당받지 않는 바리스타의 작업 시간을 업데이트한다.
      - 주문(손님)의 대기 시간을 저장한다.